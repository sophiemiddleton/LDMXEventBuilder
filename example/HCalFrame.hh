// HCalFrame.hh
#ifndef HCALFRAME_H
#define HCALFRAME_H
#pragma once
#include <vector>
#include <cstdint>

/**
 * A direct representation of the ECON-D frame for a single event.
 * Note that the internal data (channel maps, sub-packets)
 * would need to be parsed further for reconstruction.
 */
struct HCalFrame {
    std::vector<uint32_t> frame_data = {
    0xf32d5010, 0xde92c07c,  // two-word event packet header
    0xe0308fff, 0xffffffff,  // link sub-packet header with channel map
    0x01ec7f03, 0xfd07015c, 0x67026c99, 0x0fffff0f,
    0xffff0fff, 0xff0fffff, 0x017c5f0f, 0xffff0475,
    0x1b0fffff, 0x02fcbb01, 0xb46d01cc, 0x72032cd1,
    0x0254a100, 0xd43506ec, 0x0001785d, 0x0fffff03,
    0x4cd10fff, 0xff0390f4, 0x0fffff0f, 0xffff0966,
    0x630fffff, 0x00741f01, 0xbc72017c, 0x5b014457,
    0x017c6a0f, 0xffff0fff, 0xff0a3280, 0x0a5a9c00,
    0xe0328edf, 0xffffffff,  // link sub-packet header with channel map
    0x01484f02, 0x10780220, 0x7a023c8c, 0x027ca601,
    0xcc7a027c, 0x9901a869, 0x01906301, 0x6c5501ac,
    0x7402549f, 0x0264a301, 0xa85f024c, 0x99019c6f,
    0x02fcbf01, 0x745d04dc, 0x00024892, 0x026ca102,
    0x7c9d02f0, 0xc5021c86, 0x01545a01, 0xec7b0250,
    0x8e02ccad, 0x019c6602, 0x2c8f028c, 0xad0fffff,
    0x0fffff0f, 0xffff063d, 0x9902dcc6, 0x0fffff00,
    0xe03d8bff, 0xffffffff,  // link sub-packet header with channel map
    0x0188630f, 0xffff0fff, 0xff01a86a, 0x0d57500a,
    0x9aa60fff, 0xfe0fffff, 0x01bc6e0f, 0xffff0e33,
    0x940fffff, 0x02649301, 0xc8840214, 0x81023c99,
    0x0eefc101, 0x7c620198, 0x00018c64, 0x0fffff03,
    0x44d20fff, 0xff0b12c2, 0x0fffff0f, 0xffff0fff,
    0xff0fffff, 0x01585501, 0xd48301d4, 0x7d01b479,
    0x01b06a0f, 0xffff0aae, 0xa00fffff, 0x0fffff00,
    0xe0310cbf, 0xffffffff,  // link sub-packet header with channel map
    0x02047402, 0x348d0208, 0x820aaea1, 0x02449702,
    0x3895029c, 0xa801fc7f, 0x01b06d01, 0xb4750264,
    0x9801ec75, 0x018c6702, 0x7ca10234, 0x96016867,
    0x01cc7d01, 0x986601ac, 0x00015457, 0x02148101,
    0xf07f02f8, 0xbb02147b, 0x01b06501, 0xfc7502e4,
    0xb3021884, 0x016c5a0f, 0xffff0f47, 0xe50fffff,
    0x0fffff0f, 0xffff0fff, 0xff0fffff, 0x0fffff00,
    0xe0378e7f, 0xffffffff,  // link sub-packet header with channel map
    0x01dc7d01, 0xb46c0268, 0x9701f879, 0x0fffff07,
    0xa1ee03fd, 0x050fffff, 0x012c4b0f, 0xbbf602b0,
    0xad0a6e9c, 0x02589a02, 0x44970134, 0x5902ccad,
    0x0314c600, 0xf83d067c, 0x00011c47, 0x01fc7f07,
    0xb1eb0b22, 0xc801d473, 0x0a2a930d, 0xa3660274,
    0x9e0fffff, 0x00fc3f01, 0x7c5b0274, 0xa5013c53,
    0x01544f0f, 0xffff01cc, 0x72013c51, 0x095a5d00,
    0xe02889df, 0xffffffff,  // link sub-packet header with channel map
    0x02fcbf01, 0x785402a0, 0x97021885, 0x01544f01,
    0xc87102dc, 0xaf01ec7f, 0x01d47601, 0x5c5d01f0,
    0x7901f487, 0x02ecbf02, 0xdcb901c8, 0x6e02fccd,
    0x02b8ae01, 0x88620694, 0x0001cc73, 0x02348900,
    0x040109ba, 0x6a01745d, 0x020c8a01, 0xfc75025c,
    0x9f01d46f, 0x01bc6f0f, 0xffff019c, 0x690fffff,
    0x0fffff0f, 0xffff0a4a, 0x96023c87, 0x0fffff00,
    0x1bb1292f  // CRC for sub-packets
                // no IDLE word?
};
};

#endif
